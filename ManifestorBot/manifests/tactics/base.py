"""
Base tactic module interface.

All tactics inherit from TacticModule and implement the required methods.

Key design principles:
  - Tactics never inspect the Strategy enum directly.
    They call current_strategy.profile() and consume the TacticalProfile.
  - Confidence scores are built additively from named sub-signals.
    The evidence dict records every contribution so the chat commentary
    and future logging can explain exactly why a unit did what it did.
  - is_applicable() is a fast gate — return False before any math runs
    if the tactic fundamentally can't apply (wrong unit type, no valid
    targets, strategy has this tactic blocked, etc).
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import TYPE_CHECKING, Optional, FrozenSet

from ares.behaviors.combat.individual.combat_individual_behavior import (
    CombatIndividualBehavior,
)
from sc2.ids.unit_typeid import UnitTypeId as UnitID
from sc2.unit import Unit

if TYPE_CHECKING:
    from ManifestorBot.manifestor_bot import ManifestorBot
    from ManifestorBot.manifests.heuristics import HeuristicState
    from ManifestorBot.manifests.strategy import Strategy, TacticalProfile


@dataclass
class TacticIdea:
    """
    A tactic idea generated by a unit.

    This is what flows through the suppression logic before being
    converted into an actual behavior.

    The evidence dict is the paper trail — it records every sub-signal
    that contributed to the confidence score, making the bot's reasoning
    fully inspectable from the chat commentary.
    """
    tactic_module: 'TacticModule'
    confidence: float           # 0.0 to 1.0 — how good is this idea
    evidence: dict              # Named contributions (for debugging)
    target: Optional[object] = None  # Target unit, position, or None


class TacticModule(ABC):
    """
    Base class for all tactic modules.

    Each tactic is a self-contained module that knows:
      1. When it is applicable           (is_applicable)
      2. How to score the situation      (generate_idea)
      3. How to execute the decision     (create_behavior)

    Strategy integration
    --------------------
    Tactics receive the current Strategy via generate_idea() but should
    only use it by calling current_strategy.profile() to get a
    TacticalProfile. This keeps strategy→tactic coupling clean:

        profile = current_strategy.profile()
        confidence += profile.engage_bias    # additive, inspectable
        evidence['strategy_engage_bias'] = profile.engage_bias

    Blocked strategies
    ------------------
    Override blocked_strategies to return a frozenset of Strategy values
    that should cause is_applicable() to return False immediately.
    The base implementation returns an empty set (no blocking).

        @property
        def blocked_strategies(self) -> FrozenSet['Strategy']:
            from ManifestorBot.manifests.strategy import Strategy
            return frozenset({Strategy.DRONE_ONLY_FORTRESS})
    """

    def __init__(self):
        self.name: str = self.__class__.__name__

    # ---------------------------------------------------------------- #
    # Strategy gating
    # ---------------------------------------------------------------- #

    @property
    def blocked_strategies(self) -> 'FrozenSet[Strategy]':
        """
        Strategies under which this tactic should never fire.

        Return a frozenset of Strategy values. is_applicable() checks
        this automatically — subclasses don't need to call super().
        """
        return frozenset()

    # ---------------------------------------------------------------- #
    # Required interface
    # ---------------------------------------------------------------- #

    @abstractmethod
    def is_applicable(self, unit: Unit, bot: 'ManifestorBot') -> bool:
        """
        Can this tactic even be considered for this unit right now?

        This is the fast filter. Return False immediately if:
          - Wrong unit type for this tactic
          - No valid targets exist
          - Current strategy is in self.blocked_strategies
          - Any other cheap structural check

        Do NOT do confidence math here. Save that for generate_idea().
        """
        pass

    @abstractmethod
    def generate_idea(
        self,
        unit: Unit,
        bot: 'ManifestorBot',
        heuristics: 'HeuristicState',
        current_strategy: 'Strategy',
    ) -> Optional[TacticIdea]:
        """
        Score the situation and return an idea if this tactic makes sense.

        Build confidence additively from named sub-signals. Every
        contribution should be recorded in the evidence dict. The
        strategy profile bias should always be one of those contributions.

        Return None if confidence is too low to bother — this is
        different from suppression, which happens after all ideas
        are collected and sorted. Returning None here means "I have
        nothing to offer for this unit right now."

        Pattern:
            profile = current_strategy.profile()
            confidence = 0.0
            evidence = {}

            # --- sub-signal: local enemy count ---
            nearby = bot.enemy_units.closer_than(8, unit.position)
            if nearby:
                sig = min(0.3, len(nearby) * 0.06)
                confidence += sig
                evidence['nearby_enemies'] = sig

            # --- sub-signal: strategy bias ---
            confidence += profile.engage_bias
            evidence['strategy_engage_bias'] = profile.engage_bias

            if confidence < 0.15:
                return None

            return TacticIdea(self, confidence, evidence, target=...)
        """
        pass

    @abstractmethod
    def create_behavior(
        self,
        unit: Unit,
        idea: TacticIdea,
        bot: 'ManifestorBot',
    ) -> Optional[CombatIndividualBehavior]:
        """
        Convert an approved idea into an Ares behavior for execution.

        Return None if the behavior can't be constructed (e.g. target
        died between idea generation and execution). The bot will treat
        a None return as a no-op and still record the cooldown.
        """
        pass

    # ---------------------------------------------------------------- #
    # Helpers available to all tactics
    # ---------------------------------------------------------------- #

    def _is_strategy_blocked(self, current_strategy: 'Strategy') -> bool:
        """Convenience check — used internally and optionally by subclasses."""
        return current_strategy in self.blocked_strategies

    def _find_highest_threat_enemy(
        self,
        unit: Unit,
        bot: 'ManifestorBot',
        search_radius: float = 15.0,
    ) -> Optional[Unit]:
        """
        Find the highest-threat enemy unit within search_radius.

        Threat is scored as: dps * (1 / distance) * health_ratio
        This prefers units that can shoot us, are close, and are healthy
        (healthy units stay threats longer).

        Returns None if no enemies are in range.
        """
        nearby = bot.enemy_units.closer_than(search_radius, unit.position)
        if not nearby:
            return None

        best_unit = None
        best_score = -1.0

        for enemy in nearby:
            dist = max(0.5, unit.distance_to(enemy))
            # Use ground dps as a proxy for threat; fall back to 1.0 for
            # units whose DPS we can't query (structures, etc.)
            dps = enemy.ground_dps if hasattr(enemy, 'ground_dps') else 1.0
            health_ratio = enemy.health / enemy.health_max if enemy.health_max > 0 else 1.0
            score = dps * (1.0 / dist) * health_ratio
            if score > best_score:
                best_score = score
                best_unit = enemy

        return best_unit

    def _unit_distance_to_army_centroid(
        self,
        unit: Unit,
        bot: 'ManifestorBot',
    ) -> float:
        """
        Distance from this unit to the army centroid.
        Returns 0.0 if we have fewer than 3 army units.
        """
        army = bot.units.exclude_type({bot.worker_type, bot.supply_type})
        if len(army) < 3:
            return 0.0
        return unit.distance_to(army.center)

    def _health_ratio(self, unit: Unit) -> float:
        """Unit health as a 0.0–1.0 fraction."""
        if unit.health_max <= 0:
            return 1.0
        return unit.health / unit.health_max

    def _shield_ratio(self, unit: Unit) -> float:
        """Unit shield as a 0.0–1.0 fraction (0.0 for non-Protoss)."""
        if unit.shield_max <= 0:
            return 1.0
        return unit.shield / unit.shield_max

    # Worker/supply unit type sets — shared so every tactic filters consistently
    @staticmethod
    def _is_worker_or_supply(unit: Unit, bot: 'ManifestorBot') -> bool:
        return unit.type_id in {bot.worker_type, bot.supply_type,
                                 UnitID.OVERLORD, UnitID.OVERSEER}
